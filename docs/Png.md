---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(sec:gif)=
# Case Study: PNG

The [PNG format](https://en.wikipedia.org/wiki/PNG) is widely used to encode images.
We provide a [png.fan](png.fan) specification that creates PNG images.

Note that `png.fan` was created by asking ChatGPT for a Fandango PNG spec, and then applying small fixes.
See [below](sec:chatgpt-png) for details.


## The PNG format

### General Structure

A minimal PNG file consists of the following parts:
a signature `<signature>`,
a header `<ihdr>`,
an optional color palette `<plte>`,
and a footer `<iend>`:

```python
<start> ::= (
    <signature>
    <ihdr>
    <plte>?
    <idat>
    <iend>
)
```

## Signature

The signature is a fixed string of eight bytes:

```python
<signature> ::= b'\211PNG\r\n\032\n'
```

### Chunks

PNG files are composed of individual _chunks_, consisting of

* a 32-bit _length_ of the body
* a 4-character _type_ of the respective chunk
* the actual body; and
* a 32-bit CRC checksum over type and body.

For the _header_, this is defined as

```python
<ihdr> ::= <len_ihdr> b'IHDR' <ihdr_body> <ihdr_crc>

<len_ihdr> ::= <uint32>
<uint32> ::= <byte>{4}
where <len_ihdr> == from_u32(len(bytes(<ihdr_body>)))

<ihdr_crc> ::= <uint32>
where <ihdr_crc> == crc(b'IHDR', bytes(<ihdr_body>))
```

Here, `from_u32()` converts an integer into a 4-byte (32-bit) integer; and `crc()` computes the CRC checksum over the given chunk type and the contents of the body. Note how we use `bytes()` to extract the actual byte content of the `<ihdr_body>` derivation tree.

These are the helper functions we use:

```python
def to_u32(bs: bytes) -> int:
    """
    Convert a sequence of 4 bytes (big-endian) into
    an unsigned 32-bit integer.

    Args:
        bs (list[int] or bytes): Exactly 4 bytes.

    Returns:
        int: Parsed unsigned integer.
    """
    return struct.unpack(">I", bytes(bs))[0]


def from_u32(n: int) -> bytes:
    """
    Convert an integer into a 4-byte big-endian list.

    Args:
        n (int): Integer in range [0, 2^32-1].

    Returns:
        bytes: 4-byte big-endian representation.
    """
    return bytes(struct.pack(">I", n))


def crc(t: bytes, d: bytes) -> bytes:
    """
    Compute the PNG CRC field for a chunk.

    Args:
        t (bytes): 4-byte chunk type.
        d (bytes): Chunk payload.

    Returns:
        bytes: 4-byte big-endian CRC.
    """
    return from_u32(zlib.crc32(bytes(t + d)) & 0xffffffff)
```


### Header

The header body contains essential data of the PNG image:

```python
<ihdr_body> ::= (
    <width>
    <height>
    <bitdepth>
    <colortype>
    b'\x00'     # compression - (deflate/inflate compression with a 32K sliding window)
    b'\x00'     # filter
    <interlace>)

<width> ::= <uint32>
<height> ::= <uint32>
```

We fix width and height to `WIDTH` and `HEIGHT` to avoid generating huge IDAT data.

```python
<width> ::= <uint32> := from_u32(WIDTH)
<height> ::= <uint32> := from_u32(HEIGHT)
```

with

```python
WIDTH = 10
HEIGHT = 10
```

We have various choices of bit depth and color type...

```python
<bitdepth> ::= b'\x08' | b'\x10'
<colortype> ::= b'\x02' | b'\x06'
<interlace> ::= b'\x00'
```

... but only certain combinations are allowed:

```python
# Note: ord(b'\x02') == 2
where valid_ihdr(ord(bytes(<bitdepth>)), ord(bytes(<colortype>)))

def valid_ihdr(bitdepth: int, colortype: int) -> bool:
    """
    Check whether a (bitdepth, colortype) combination
    is valid according to the PNG specification.

    PNG allows only certain combinations, e.g.:
        ColorType 2 (RGB) supports 8 or 16 bits.

    Args:
        bitdepth (int)
        colortype (int)

    Returns:
        bool: True if combination is legal.
    """
    valid = {
        0: {1,2,4,8,16},
        2: {8,16},
        3: {1,2,4,8},
        4: {8,16},
        6: {8,16}
    }
    return colortype in valid and bitdepth in valid[colortype]
```


We also fix the bit depths and color type.

```python
<bitdepth> ::= b'\x08'
<colortype> ::= b'\x02'
```


### Palettes

In our generator, color palettes are just random sequences of bytes.

```python
<plte> ::= <len_plte> b'PLTE' <plte_data> <plte_crc>
where to_u32(<len_plte>) % 3 == 0
where <len_plte> == from_u32(len(bytes(<plte_data>)))
where <plte_crc> == crc(b'PLTE', bytes(<plte_data>))

<plte_data> ::= <byte>*
<len_plte> ::= <uint32>
<plte_crc> ::= <uint32>
```

## Data Chunks

The `IDAT` chunk holds the actual image, generated by a function `generate_idat()`.
Again, we fix the size of the PNG to 10x10.

```python
<idat> ::= <generated_idat>

<generated_idat> ::= <len_idat> b'IDAT' <idat_data> <idat_crc> := generate_idat(
        to_u32(<width>),
        to_u32(<height>),
        ord(bytes(<bitdepth>)),
        ord(bytes(<colortype>))
    )

<len_idat> ::= <uint32>
<idat_crc> ::= <uint32>
<idat_data> ::= <byte>*

# where to_u32(<len_idat>) % 3 == 0
where <len_idat> == from_u32(len(bytes(<idat_data>)))
where <idat_crc> == crc(b'IDAT', bytes(<idat_data>))
```

The function `generate_idat()` is defined as follows:

```python
def channels(colortype: int) -> int:
    """
    Return number of color channels for a PNG color type.

    Mapping:
        0 → Grayscale (1)
        2 → RGB (3)
        3 → Indexed (1)
        4 → Grayscale + Alpha (2)
        6 → RGBA (4)

    Args:
        colortype (int)

    Returns:
        int: Number of channels.
    """
    return {0:1, 2:3, 3:1, 4:2, 6:4}[colortype]


def scanline_size(width: int, bitdepth: int, colortype: int) -> int:
    """
    Compute number of bytes in a PNG scanline
    excluding the filter byte.

    Formula:
        ceil(width * channels * bitdepth / 8)

    Args:
        width (int)
        bitdepth (int)
        colortype (int)

    Returns:
        int: Number of pixel bytes per scanline.
    """
    bits = width * channels(colortype) * bitdepth
    return math.ceil(bits / 8)


def generate_scanlines(width: int, height: int, bitdepth: int, colortype: int) -> bytes:
    """
    Construct raw PNG image data (before compression).

    Each scanline consists of:
        1 filter byte (0–4)
        pixel bytes

    Filter types are randomly selected.
    Pixel bytes are uniformly random.

    Args:
        width (int)
        height (int)
        bitdepth (int)
        colortype (int)

    Returns:
        bytes: Raw uncompressed image bytes.
    """
    size = scanline_size(width, bitdepth, colortype)
    raw = []
    for _ in range(height):
        filter_type = random.randint(0,4)
        raw.append(filter_type)
        raw.extend(random.randint(0,255) for _ in range(size))
    return bytes(raw)


def generate_idat(width: int, height: int, bitdepth: int,
                  colortype: int) -> bytes:
    """
    Generate a complete, valid PNG IDAT chunk.

    Steps:
        1. Generate raw scanlines
        2. Compress using zlib (DEFLATE)
        3. Compute correct chunk length
        4. Compute correct CRC

    Args:
        width (int)
        height (int)
        bitdepth (int)
        colortype (int)

    Returns:
        bytes: Full IDAT chunk bytes including:
            length || 'IDAT' || compressed_data || crc
    """
    raw = generate_scanlines(width, height, bitdepth, colortype)
    compressed = bytes(list(zlib.compress(bytes(raw))))
    length = from_u32(len(compressed))
    crc_value = crc(b'IDAT', bytes(compressed))
    return bytes(length + b'IDAT' + compressed + crc_value)
```


### Footer

The last chunk in a PNG file must be an `IEND` chunk, indicating end of file:

```python
<iend> ::= <len_iend> b'IEND' <iend_crc>
where <len_iend> == from_u32(0)
where <iend_crc> == crc(b'IEND', b'')

<len_iend> ::= <uint32>
<iend_crc> ::= <uint32>
```

## Using `png.fan`

You can easily invoke Fandango with [png.fan](png.fan) to fuzz PNG images:

```shell
$ fandango fuzz -f png.fan -n 1 -o 10x10.png
```

and you will obtain a 10x10 image [10x10.png](10x10.png) such as this one:

```{image} 10x10.png
:alt: Generated PNG file
:class: bg-primary mb-1
:width: 100px
:align: center
```

(sec:sec:chatgpt-png)=
## How we obtained the PNG file from ChatGPT

The above file [png.fan](png.fan) was actually obtained from the _ChatGPT_ large language model.
The prompts were:

1. What is a png file made of?
2. Can you express the structure as a grammar?
3. Express it in a formal attribute grammar notation
4. Express this as a Fandango specification (see https://fandango-fuzzer.github.io/)
5. Provide a full .fan file, including pixel decompression and filter constraints
6. Add a custom generator for IDAT payload
7. Add docstrings to these functions

At this point, the returned specification file looked like this: [png-chatgpt.fan](png-chatgpt.fan),
which is remarkably close to a correct PNG spec.
However, this file was still somewhat erroneous.

### Fixing Syntax Errors

ChatGPT assumed that in Fandango, Python `import` commands would be prefixed by a `:`:

```python
:import struct
:import zlib
:import math
:import random
```

This was easily fixed by replacing `:import` with `import`.

Also, the generated code assumed that rules would continue while being indented:

```python
<start> ::=
    <signature>
    <ihdr>
    <plte>?
    <idat>
    <iend>
```

This was easily fixed by putting parentheses around the expansion:

```python
<start> ::= (
    <signature>
    <ihdr>
    <plte>?
    <idat>
    <iend>)
```


### Fixing Semantic Errors

ChatGPT knows how to invoke a generator function.
However, fields like `<width>` and `<height>` would be generated anew every time,
so this only works if they are set to fixed values.

```python
<generated_idat> ::=
    :python generate_idat(
        to_u32(<width>),
        to_u32(<height>),
        <bitdepth>[0],
        <colortype>[0]
    )
```

The fixed version reads like this.
Note that we also parse (and check) the returned byte string.

```python
<generated_idat> ::= <len_idat> b'IDAT' <idat_data> <idat_crc> := generate_idat(
        to_u32(<width>),
        to_u32(<height>),
        ord(bytes(<bitdepth>)),
        ord(bytes(<colortype>))
    )

# Basic parameters
WIDTH = 10
HEIGHT = 10

# We fix width and height to 10 to avoid generating huge IDAT data.
<width> ::= <uint32> := from_u32(WIDTH)
<height> ::= <uint32> := from_u32(HEIGHT)

# We stick with simple bit depths and color types
<bitdepth> ::= b'\x08'
<colortype> ::= b'\x02'
```

A final bummer was that the ChatGPT-generated version redefined `<byte>` to a single dot:

```python
<byte> ::= b'.'
```

This is wrong - even if a dot were a regular expression, it would not match newlines.
So this had to be removed.


### Scoping

The ChatGPT-generated specification reused the same identifiers over and over, notably lengths and CRC checksums:

```python
<plte> ::= <len_plte> b'PLTE' <data> <crc>
where crc_ok(b'PLTE', <data>, <crc>)
```

```python
<ihdr> ::= <len_13> b'IHDR' <ihdr_body> <crc>
where crc_ok(b'IHDR', <ihdr_body>, <crc>)
```

Alas, in Fandango, all nonterminals have a global scope.
Hence, the above constraints would thus enforce that _any_ `<crc>` element be _both_ the checksum over `<data>` and `<ihrd_body>`.
This is easily fixed by introducing separate `<plte_crc>` and `<ihdr_crc>` elements, each with its own constraints.


### Optimizations

The ChatGPT-produced PNG spec uses a `crc_ok()` function that would check whether a CRC is correct, as in:

```python
where crc_ok(b'IHDR', <ihdr_body>, <crc>)
```

The `crc_ok()` function would check if the given field type, body, and CRC all match each other:

```python
def crc_ok(t, d, c):
    """
    Verify that a PNG chunk CRC is correct.

    The CRC is computed over:
        chunk_type || chunk_data

    Args:
        t (list[int]): 4-byte chunk type.
        d (list[int]): Chunk payload.
        c (list[int]): 4-byte CRC field.

    Returns:
        bool: True if CRC matches PNG specification.
    """
    return (zlib.crc32(bytes(t + d)) & 0xffffffff) == to_u32(c)
```

Such a function is useful for _validating_ a CRC during parsing.
For _producing_, however, it is not very helpful.
This is because Fandango has to _solve_ the checksum constraint - that is, finding a pair of payload and CRC that march each other.
Since CRCs are essentially chaotic, the evolutionary algorithm would have no guidance, and degrade to a _very_ lengthy 
trial-and-error process – on average, $2^{32} = 4,294,967,296$ trials until it finds a valid CRC.

This is easily fixed by replacing the constraint with a _constructive_ computation, using a new `crc()` function:

```python
where <idat_crc> == crc(b'IDAT', bytes(<idat_data>))
```

Here, Fandango can easily solve the constraint by computing the right-hand side of the equation from given `<idat_data>`, and thus obtaining a straightforward solution for the `<idat_crc>` field.


### Correct parts

* The basic structure of the PNG file was correct
* The PNG signature, header, ending were correct
* Conversion functions and CRC computation was correct
* `generate_idat()` and all its code for producing PNG data was correct

All in all, applying the above fixes to obtain a valid PNG specification for Fandango (and thus a PNG fuzzer) took about 30 minutes; and then, the final [png.fan](png.fan) was ready.


### One prompt to have it all?

Can one have it all in one prompt?
