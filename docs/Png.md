---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(sec:gif)=
# Case Study: PNG

The [PNG format](https://en.wikipedia.org/wiki/PNG) is widely used to encode images.
We provide a [png.fan](png.fan) specification that creates PNG images.

Note that `png.fan` was created by asking ChatGPT for a Fandango PNG spec, and then applying small fixes.
See [below](sec:chatgpt-png) for details.


## The PNG format

### General Structure

A minimal PNG file consists of the following parts:
a signature `<signature>`,
a header `<ihdr>`,
an optional color palette `<plte>`,
and a footer `<iend>`:

```python
<start> ::= (
    <signature>
    <ihdr>
    <plte>?
    <idat>
    <iend>
)
```

## Signature

The signature is a fixed string of eight bytes:

```python
<signature> ::= b'\211PNG\r\n\032\n'
```

### Chunks

PNG files are composed of individual _chunks_, consisting of

* a 32-bit _length_ of the body
* a 4-character _type_ of the respective chunk
* the actual body; and
* a 32-bit CRC checksum over type and body.

For the _header_, this is defined as

```python
<ihdr> ::= <len_ihdr> b'IHDR' <ihdr_body> <ihdr_crc>

<len_ihdr> ::= <uint32>
<uint32> ::= <byte>{4}
where <len_ihdr> == from_u32(len(bytes(<ihdr_body>)))

<ihdr_crc> ::= <uint32>
where <ihdr_crc> == crc(b'IHDR', bytes(<ihdr_body>))
```

Here, `from_u32()` converts an integer into a 4-byte (32-bit) integer; and `crc()` computes the CRC checksum over the given chunk type and the contents of the body. Note how we use `bytes()` to extract the actual byte content of the `<ihdr_body>` derivation tree.

These are the helper functions we use:

```python
def to_u32(bs: bytes) -> int:
    """
    Convert a sequence of 4 bytes (big-endian) into
    an unsigned 32-bit integer.

    Args:
        bs (list[int] or bytes): Exactly 4 bytes.

    Returns:
        int: Parsed unsigned integer.
    """
    return struct.unpack(">I", bytes(bs))[0]


def from_u32(n: int) -> bytes:
    """
    Convert an integer into a 4-byte big-endian list.

    Args:
        n (int): Integer in range [0, 2^32-1].

    Returns:
        bytes: 4-byte big-endian representation.
    """
    return bytes(struct.pack(">I", n))


def crc(t: bytes, d: bytes) -> bytes:
    """
    Compute the PNG CRC field for a chunk.

    Args:
        t (bytes): 4-byte chunk type.
        d (bytes): Chunk payload.

    Returns:
        bytes: 4-byte big-endian CRC.
    """
    return from_u32(zlib.crc32(bytes(t + d)) & 0xffffffff)
```


### Header

The header body contains essential data of the PNG image:

```
<ihdr_body> ::= (
    <width>
    <height>
    <bitdepth>
    <colortype>
    b'\x00'     # compression - (deflate/inflate compression with a 32K sliding window)
    b'\x00'     # filter
    <interlace>)

<width> ::= <uint32>
<height> ::= <uint32>
```

We fix width and height to 10 to avoid generating huge IDAT data.
```python
where <width> == from_u32(10)
where <height> == from_u32(10)
```

We have various choices of bit depth and color type...

```python
<bitdepth> ::= b'\x08' | b'\x10'
<colortype> ::= b'\x02' | b'\x06'
<interlace> ::= b'\x00'
```

... but only certain combinations are allowed:

```python
# Note: ord(b'\x02') == 2
where valid_ihdr(ord(bytes(<bitdepth>)), ord(bytes(<colortype>)))

def valid_ihdr(bitdepth: int, colortype: int) -> bool:
    """
    Check whether a (bitdepth, colortype) combination
    is valid according to the PNG specification.

    PNG allows only certain combinations, e.g.:
        ColorType 2 (RGB) supports 8 or 16 bits.

    Args:
        bitdepth (int)
        colortype (int)

    Returns:
        bool: True if combination is legal.
    """
    valid = {
        0: {1,2,4,8,16},
        2: {8,16},
        3: {1,2,4,8},
        4: {8,16},
        6: {8,16}
    }
    return colortype in valid and bitdepth in valid[colortype]
```


### Palettes

In our generator, color palettes are just random sequences of bytes.

```python
<plte> ::= <len_plte> b'PLTE' <plte_data> <plte_crc>
where to_u32(<len_plte>) % 3 == 0
where <len_plte> == from_u32(len(bytes(<plte_data>)))
where <plte_crc> == crc(b'PLTE', bytes(<plte_data>))

<plte_data> ::= <byte>*
<len_plte> ::= <uint32>
<plte_crc> ::= <uint32>
```

## Data Chunks

The `IDAT` chunk holds the actual image, generated by a function `generate_idat()`.
Again, we fix the size of the PNG to 10x10.

```python
<idat> ::= <generated_idat>

<generated_idat> ::= <len_idat> b'IDAT' <idat_data> <idat_crc> := generate_idat(
        10, # to_u32(<width>),
        10, # to_u32(<height>),
        1, # <bitdepth>[0],
        0, # <colortype>[0]
    )

<len_idat> ::= <uint32>
<idat_crc> ::= <uint32>
<idat_data> ::= <byte>*

# where to_u32(<len_idat>) % 3 == 0
where <len_idat> == from_u32(len(bytes(<idat_data>)))
where <idat_crc> == crc(b'IDAT', bytes(<idat_data>))
```

The function `generate_idat()` is defined as follows:

```python
def channels(colortype: int) -> int:
    """
    Return number of color channels for a PNG color type.

    Mapping:
        0 → Grayscale (1)
        2 → RGB (3)
        3 → Indexed (1)
        4 → Grayscale + Alpha (2)
        6 → RGBA (4)

    Args:
        colortype (int)

    Returns:
        int: Number of channels.
    """
    return {0:1, 2:3, 3:1, 4:2, 6:4}[colortype]


def scanline_size(width: int, bitdepth: int, colortype: int) -> int:
    """
    Compute number of bytes in a PNG scanline
    excluding the filter byte.

    Formula:
        ceil(width * channels * bitdepth / 8)

    Args:
        width (int)
        bitdepth (int)
        colortype (int)

    Returns:
        int: Number of pixel bytes per scanline.
    """
    bits = width * channels(colortype) * bitdepth
    return math.ceil(bits / 8)


def generate_scanlines(width: int, height: int, bitdepth: int, colortype: int) -> bytes:
    """
    Construct raw PNG image data (before compression).

    Each scanline consists of:
        1 filter byte (0–4)
        pixel bytes

    Filter types are randomly selected.
    Pixel bytes are uniformly random.

    Args:
        width (int)
        height (int)
        bitdepth (int)
        colortype (int)

    Returns:
        bytes: Raw uncompressed image bytes.
    """
    size = scanline_size(width, bitdepth, colortype)
    raw = []
    for _ in range(height):
        filter_type = random.randint(0,4)
        raw.append(filter_type)
        raw.extend(random.randint(0,255) for _ in range(size))
    return bytes(raw)


def generate_idat(width: int, height: int, bitdepth: int,
                  colortype: int) -> bytes:
    """
    Generate a complete, valid PNG IDAT chunk.

    Steps:
        1. Generate raw scanlines
        2. Compress using zlib (DEFLATE)
        3. Compute correct chunk length
        4. Compute correct CRC

    Args:
        width (int)
        height (int)
        bitdepth (int)
        colortype (int)

    Returns:
        bytes: Full IDAT chunk bytes including:
            length || 'IDAT' || compressed_data || crc
    """
    raw = generate_scanlines(width, height, bitdepth, colortype)
    compressed = bytes(list(zlib.compress(bytes(raw))))
    length = from_u32(len(compressed))
    crc_value = crc(b'IDAT', bytes(compressed))
    return bytes(length + b'IDAT' + compressed + crc_value)
```


### Footer

The last chunk in a PNG file must be an `IEND` chunk, indicating end of file:

```python
<iend> ::= <len_iend> b'IEND' <iend_crc>
where <len_iend> == from_u32(0)
where <iend_crc> == crc(b'IEND', b'')

<len_iend> ::= <uint32>
<iend_crc> ::= <uint32>
```

## Using `png.fan`

You can easily invoke Fandango with [png.fan](png.fan) to fuzz PNG images:

```shell
$ fandango fuzz -f png.fan -n 1 -o 10x10.png
```

and you will obtain a 10x10 image [10x10.png](10x10.png) such as this one:

```{image} 10x10.png
:alt: Generated PNG file
:class: bg-primary mb-1
:width: 100px
:align: center
```
