# evolution/algorithm.py
import copy
import random
import time
from typing import List, Set, Tuple

from fandango.constraints.base import Constraint
from fandango.constraints.fitness import Comparison, ComparisonSide, FailingTree
from fandango.evolution.profiler import Profiler
from fandango.language.grammar import (
    DerivationTree,
    Grammar,
)


class FANDANGO:
    def __init__(
        self,
        grammar: Grammar,
        constraints: List[Constraint],
        population_size: int = 100,
        desired_solutions: int = 0,
        initial_population: List[DerivationTree] = None,
        max_generations: int = 500,
        elitism_rate: float = 0.1,
        crossover_rate: float = 0.8,
        tournament_size: float = 0.1,
        mutation_rate: float = 0.2,
        verbose: bool = False,
        profiling: bool = False,
        subject: str = "default",
        run: int = 1,
        rounds: int = 1,
    ):
        """
        Initialize the FANDANGO genetic algorithm. The algorithm will evolve a population of individuals
        that are generated by the given grammar, and will evaluate them against the given constraints.

        :param grammar: The grammar used to generate individuals.
        :param constraints: The constraints used to evaluate individuals.
        :param population_size: The size of the population.
        :param max_generations: The maximum number of generations to run the algorithm.
        :param elitism_rate: The rate of individuals that will be preserved in the next generation.
        :param crossover_rate: The rate of individuals that will undergo crossover.
        :param mutation_rate: The rate of individuals that will undergo mutation.
        :param verbose: Whether to print information about the evolution process.
        """
        if verbose:
            print(" ---------- Initializing FANDANGO algorithm ---------- ")
        self.grammar = grammar
        self.rounds = rounds
        self.constraints = constraints
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.tournament_size = int(population_size * tournament_size) or population_size
        self.max_generations = max_generations
        self.elitism_rate = elitism_rate
        self.subject = subject
        self.fitness_cache = {}
        self.constraint_profile = []
        self.verbose = verbose
        self.fixes_made = 0
        self.checks_made = 0
        self.crossovers_made = 0
        self.mutations_made = 0

        self.time_taken = None
        self.profiler = Profiler(enabled=True)
        self.run = run
        # Initialize population
        self.solution = list()
        self.profiling_results = None

        self.desired_solutions = desired_solutions

        self.profiler.start_timer("initial_population")
        self.population = self.generate_random_initial_population()
        self.profiler.stop_timer("initial_population")
        self.profiler.increment("initial_population", len(self.population))

        # Evaluate population
        self.evaluation = self.evaluate_population()
        self.fitness = (
            sum(fitness for _, fitness, _ in self.evaluation) / self.population_size
        )
        if self.verbose:
            print(" ---------- Starting evolution ---------- ")

    def evolve(self) -> List[DerivationTree]:
        """
        Run the genetic algorithm to evolve the population over multiple generations.

        :return: The best solution found by the algorithm.
        """
        start_time = time.time()

        for generation in range(1, self.max_generations + 1):
            if 0 < self.desired_solutions <= len(self.solution):
                self.fitness = 1.0
                self.solution = self.solution[: self.desired_solutions]
                break
            elif self.desired_solutions == 0:
                if self.fitness >= 0.99:
                    self.fitness = 1.0
                    self.solution = self.population[: self.population_size]
                    break
                if len(self.solution) >= self.population_size:
                    self.fitness = 1.0
                    self.solution = self.solution[: self.population_size]
                    break

            if self.verbose:
                print(
                    f"[INFO] - Generation {generation} - Fitness: {self.fitness:.2f} - "
                    f"#solutions found: {len(self.solution)}"
                )

            # Select elites
            self.profiler.start_timer("select_elites")
            new_population = self.select_elites()
            self.profiler.stop_timer("select_elites")
            self.profiler.increment("select_elites", len(new_population))

            # Crossover
            while len(new_population) < self.population_size:
                if random.random() < self.crossover_rate:
                    self.profiler.start_timer("tournament_selection")
                    parent1, parent2 = self.tournament_selection()
                    self.profiler.stop_timer("tournament_selection")
                    self.profiler.increment("tournament_selection", 2)
                    self.profiler.start_timer("crossover")
                    child1, child2 = self.crossover(parent1, parent2)
                    self.profiler.stop_timer("crossover")
                    self.profiler.increment("crossover", 2)
                    new_population.append(child1)
                    new_population.append(child2)
                    self.crossovers_made += 1

            new_population = new_population[: self.population_size]

            # Mutation
            for individual in new_population:
                if random.random() < self.mutation_rate:
                    new_population.remove(individual)
                    self.profiler.start_timer("mutation")
                    new_population.append(self.mutate(individual))
                    self.profiler.stop_timer("mutation")
                    self.profiler.increment("mutation", 1)
                    self.mutations_made += 1

            # Add new individuals
            curr_size = len(new_population)
            self.profiler.start_timer("filling")
            while len(new_population) < self.population_size:
                new_population.append(self.grammar.fuzz())
            self.profiler.stop_timer("filling")
            self.profiler.increment("filling", len(new_population) - curr_size)

            # Fix individuals
            fixed_population = list()
            for individual in new_population:
                fixed_population.append(self.fix_individual(individual))

            # Evaluate population
            self.population = fixed_population[: self.population_size]
            self.evaluation = self.evaluate_population()
            self.fitness = (
                sum(fitness for _, fitness, _ in self.evaluation) / self.population_size
            )

        self.time_taken = time.time() - start_time

        if self.verbose:
            print(" ---------- Evolution finished ---------- ")
            print(
                f"[INFO] - Perfect solutions found: ({len(self.solution)}) "
                f"- Fitness of final population: {self.fitness:.2f}"
            )
            print(f"[INFO] - Time taken: {self.time_taken:.2f} seconds")

        if self.verbose:
            print(" ---------- FANDANGO statistics ---------- ")
            print(f"[DEBUG] - Fixes made: {self.fixes_made}")
            print(f"[DEBUG] - Fitness checks: {self.checks_made}")
            print(f"[DEBUG] - Crossovers made: {self.crossovers_made}")
            print(f"[DEBUG] - Mutations made: {self.mutations_made}")

        self.profiling_results = self.profiler.metrics

        import csv
        import os

        output_dir = f"execution/{self.rounds}/{self.subject}/{self.run}/"
        os.makedirs(output_dir, exist_ok=True)

        with open(
            os.path.join(output_dir, "evaluations.csv"), "w", newline=""
        ) as csvfile:
            writer = csv.writer(csvfile, delimiter=";")
            writer.writerow(["nodes", "time"])  # header
            for indi, tim in self.constraint_profile:
                writer.writerow([int(indi), tim])

            # if isinstance(indi, DerivationTree):
            #     with open(
            #         f"execution/{self.subject}/{self.run:10d}/devtree/devtree{i:04d}.txt",
            #         "w",
            #     ) as f:
            #         f.write(str(indi))
            #     with open(
            #         f"execution/{self.subject}/{self.run:10d}/constr/constr{i:04d}.txt",
            #         "w",
            #     ) as f:
            #         f.write(str(constr))
            #     with open(
            #         f"execution/{self.subject}/{self.run:10d}/time/time{i:04d}.txt", "w"
            #     ) as f:
            #         f.write(str(tim))

            #     i += 1

        return self.population

    def generate_random_initial_population(self) -> List[DerivationTree]:
        """
        Generate the initial population of individuals.

        :return: A set of individuals.
        """

        population = [self.grammar.fuzz() for _ in range(self.population_size)]

        # Fix individuals
        fixed_population = list()
        for individual in population:
            fixed_population.append(self.fix_individual(individual))

        return fixed_population

    def generate_coverage_based_initial_population(self) -> Set[DerivationTree]:
        """
        Generate the initial population of individuals that maximize the coverage of the grammar.

        :return: A set of individuals.
        """
        pass

    def fix_individual(self, individual: DerivationTree) -> DerivationTree:
        """
        Fix an individual by replacing failing subtrees if ComparisonConstraint.EQUAL are involved.
        """

        evaluation = self.evaluate_individual(individual)
        failing_trees = evaluation[1]
        for failing_tree in failing_trees:
            for operator, value, side in failing_tree.suggestions:
                if operator == Comparison.EQUAL and side == ComparisonSide.LEFT:
                    suggested_tree = self.grammar.parse(
                        str(value), failing_tree.tree.symbol
                    )
                    if suggested_tree is None:
                        continue
                    self.profiler.start_timer("fixing")
                    individual = individual.replace(failing_tree.tree, suggested_tree)
                    self.profiler.stop_timer("fixing")
                    self.profiler.increment("fixing", 1)
                    self.fixes_made += 1
        return individual

    def evaluate_individual(
        self, individual: DerivationTree
    ) -> Tuple[float, List[FailingTree]]:
        """
        Evaluate the fitness of an individual.

        :param individual: The individual to evaluate.
        :return: The fitness of the individual and the list of failing trees.
        """
        fitness = 0.0
        failing_trees = []
        if str(individual) in self.fitness_cache:
            return self.fitness_cache[str(individual)]

        str_time = time.time()
        for constraint in self.constraints:
            self.profiler.start_timer("evaluate_individual_constr")
            result = constraint.fitness(individual)
            self.profiler.stop_timer("evaluate_individual_constr")
            self.profiler.increment("evaluate_individual_constr", 1)
            if result.success:
                fitness += result.fitness()
            else:
                failing_trees.extend(result.failing_trees)
                fitness += result.fitness()
        self.constraint_profile.append([int(individual.size()), time.time() - str_time])

        # Normalize fitness
        try:
            fitness /= len(self.constraints)
        except ZeroDivisionError:
            fitness = 1.0

        if fitness >= 0.99:
            self.solution.append(individual)

        self.fitness_cache[str(individual)] = [fitness, failing_trees]
        return fitness, failing_trees

    def evaluate_population(
        self,
    ) -> List[Tuple[DerivationTree, float, List[FailingTree]]]:
        """
        Evaluate the fitness of each individual in the population.

        :return: A list of tuples, each containing an individual, its fitness, and the list of failing trees.
        """
        evaluation = []
        for individual in self.population:
            self.profiler.start_timer("evaluate_individual")
            fitness, failing_trees = self.evaluate_individual(individual)
            self.profiler.stop_timer("evaluate_individual")
            self.profiler.increment("evaluate_individual", 1)
            evaluation.append((individual, fitness, failing_trees))
        return evaluation

    def select_elites(self) -> List[DerivationTree]:
        """
        Select the 'elitism'% elite individuals from the population based on the fitness.

        :return: A list of elite individuals.
        """
        return [
            x[0]
            for x in sorted(self.evaluation, key=lambda x: x[1], reverse=True)[
                : int(self.elitism_rate * self.population_size)
            ]
        ]

    def tournament_selection(self) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform tournament selection to choose two parents for crossover.
        """
        tournament = random.sample(self.evaluation, k=self.tournament_size)
        tournament.sort(key=lambda x: x[1], reverse=True)
        parent1 = tournament[0][0]
        parent2 = tournament[1][0]
        return parent1, parent2

    # noinspection PyMethodMayBeStatic
    def crossover(
        self, parent1: DerivationTree, parent2: DerivationTree
    ) -> Tuple[DerivationTree, DerivationTree]:
        """
        Perform crossover between two parents to generate two children by swapping subtrees rooted at a common
        non-terminal symbol.
        """
        # Get all non-terminal symbols in parent1 and parent2
        symbols1 = parent1.get_non_terminal_symbols()
        symbols2 = parent2.get_non_terminal_symbols()

        # Find common non-terminal symbols
        common_symbols = symbols1.intersection(symbols2)

        if not common_symbols:
            return parent1, parent2

        # Randomly select a common non-terminal symbol
        symbol = random.choice(list(common_symbols))

        # Find all nodes with that symbol in parent1 and parent2
        nodes1 = parent1.find_all_nodes(symbol)
        nodes2 = parent2.find_all_nodes(symbol)

        # Randomly select one node from each parent
        node1 = random.choice(nodes1)
        node2 = random.choice(nodes2)

        # Swap subtrees
        child1 = parent1.replace(node1, copy.deepcopy(node2))
        child2 = parent2.replace(node2, copy.deepcopy(node1))

        return child1, child2

    def mutate(self, individual: DerivationTree) -> DerivationTree:
        """
        Perform mutation on an individual to generate a new individual based on the failing trees.
        """
        failing_trees = self.evaluate_individual(individual)[1]
        selection = []

        for failing_tree in failing_trees:
            selection.append(failing_tree.tree)

        if len(selection) == 0:
            return individual
        else:
            node_to_mutate = random.choice(selection)
            if node_to_mutate.symbol.is_non_terminal:
                new_subtree = self.grammar.fuzz(node_to_mutate.symbol)
                individual = individual.replace(node_to_mutate, new_subtree)
                self.mutations_made += 1
        return individual
